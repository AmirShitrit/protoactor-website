# Chat Example Using Proto.Remote

In this example we are going to go beyond `Proto.Actor` and leverage `Proto.Remote` package in order to enable by directional communication 
between different actors living in actor systems partitioned by network (located on different machines) in a client to server fashion, thus
enabling us to create a basic distributed system of actors.

## Proto.Remote
Communication between actors living in the same actor system is pretty straightforward and reliable task for `Proto.Actor` to acomplish
but briniging the network into play is a whole different ball game. As soon as we connect two machines together over the network we get a distributed system which is prone to all kinds of issues that simply don't exist when operating in a comfort of a single node.\
To learn mora about this, read about fallacies of distributed computing [here](https://en.wikipedia.org/wiki/Fallacies_of_distributed_computing).

What `Proto.Remote` does for us is that it abstracts many of these issues away from us and let's us concentrate on our application. It offers what is called a location transparency that enables us to treat communication between actors on different machines same as communication between actors in the local system by using nothing more than process `PIDs`.

## gRPC
The way `Proto.Remote` acomplishes this is by using `gRPC` as an underlying transport that deals with the messy details of service to service communication. Without going further into details it suffices to say that it leverages HTTP2 protocol streaming capability that enables by-directional
streaming between machines.\
Another very poverfull thing that `gRPC` enables us to do is to combine actor systems written in different programming languages. So for example
you might have one actor system written in `Go` and another using `C#` and they would seamlesly interop with each other.\
You can read more about `gRPC` [here](https://grpc.io/).

## Protocol Buffers
The way gRPC enables us to have this is that it uses the main ingredient named [Protocol Buffers](https://developers.google.com/protocol-buffers) aka Protobuf.
Protobuf is an interface deffinition language that enables us to define contracts between services (messages and endpoints) in a language netural fashion. We can then take these contracts and use gRPC in order to generate clients and servers in different languages which take care of 
all of the transport mechanism and leaves us only to implement our application code.

## Protobuf chat messages
So, now that we know how gRPC and Protobuf enable us to communicate between different servers, the first thing we need to do is
define our contracts (actor messages) using Protobuf IDL.

```protobuf
syntax = "proto3";
package messages;
option csharp_namespace = "chat.messages";
import "Proto.Actor/Protos.proto";

message Connect
{
	actor.PID Sender = 1;
}

message Connected {
    string Message = 1;
}

message SayRequest {
    string UserName = 1;
    string Message = 2;
}

message SayResponse {
    string UserName = 1;
    string Message = 2;
}

message NickRequest {
    string OldUserName = 1;
    string NewUserName = 2;
}

message NickResponse {
    string OldUserName = 1;
    string NewUserName = 2;
}
```
As you see, the language itself is pretty straight forward but in order to fully understand it you can read more about it [here](https://developers.google.com/protocol-buffers/docs/overview). For now it is enough to say that based on this deffiniton message classes will be autogenerated in our respective languages (in this case C# and Go)
as class libraries / packages which we can then use in our client and server implementations.

## Server
First, let's take a look at our server implementation.
